{"name":"Oryol","tagline":"Experimental C++11 multi-platform 3D engine","body":"oryol\r\n=====\r\n \r\nExperimental C++11 multi-platform 3D engine\r\n\r\n### Goals\r\n\r\n1. github-centric distributed development model, this is only an idea at the moment:\r\n  - the engine is made of code modules, which are independent github projects\r\n  - code modules compile to static link libraries\r\n  - the 'main project' only has build system scripts, no actual source code\r\n  - modules have a manifest file which defines dependencies to other modules\r\n  - an Oryol project also has a manifest which lists the modules it needs\r\n  - some build system magic gathers all the required module files from several github projects, and automagically creates the build files for compiling and linking the whole project\r\n\r\n2. multi-platform build system:\r\n  - at the core are cmake scripts with a lot of custom macros to simplify the definition of **libs** (3rd party code compiled into static link libs, **modules** (Oryol code modules with dependencies to other modules, compiled into static link libs), and **apps** (actual executables)\r\n  - above cmake there's a python helper script which manages different build configurations (host platforms and their native IDEs / build tools, cross-compiling, release vs. debug etc...)\r\n\r\n3. unit testing integrated into the development process:\r\n  - Oryol integrates UnitTest++ into the build process, and writing unit tests is a seamless part of the development process\r\n\r\n4. multi-platform with focus on web / mobile:\r\n  - make it extremely easy to support new POSIX+OpenGL-style target platforms\r\n  - make it possible to support non-POSIX / non-OpenGL-style target platfomrs\r\n  - feature base-line is OpenGLES2 + some common GL extensions\r\n  - support building on Linux, Mac, Windows (cmake makes this easy)\r\n\r\n5. keep the code base lean and mean:\r\n  - only implement what's necessary for a client-side game engine\r\n  - only pull in external libs if they don't bloat the code base\r\n  - client download size is important for web platforms\r\n\r\n6. be web-friendly:\r\n  - don't require pthread-style multi-threading, but support it when it's there\r\n  - all data-loading happens asynchronously\r\n  - use the HTTP philosophy for the IO system design instead of open/read/close\r\n\r\n### Architecture:\r\n\r\n- single main + render thread\r\n- frame-callback based, don't own the game loop\r\n- try to move compute tasks to GPU (e.g. transform flattening, animation evaluation, particle systems, ...)\r\n- parallel-task system for expensive CPU work (also abstracts pthread-style and worker-style multithreading)\r\n\r\n#### Core:\r\n  - memory management, pool allocators\r\n  - various string classes (immutable, UTF-8 vs. Wide, string atoms, ...)\r\n  - various custom container classes (ring buffer, double-ended arrays, ...)\r\n  - object-model: smart pointers and ref-counting\r\n  - logging\r\n  - some lock-less threading stuff that is not provided by std::atomic or std::thread\r\n  - don't use C++ excpetions and rtti\r\n  - custom assert with pretty-printed function signature, call stack and human-readable message\r\n\r\n#### IO:\r\n  - asynchronous file loading\r\n  - URLs, Amiga-style Assigns, Streams, StreamReaders, StreamWriters\r\n  - pluggable filesystems\r\n\r\n### Messaging:\r\n  - XML \"message definition files\" converted to C++ source/header files during build\r\n  - message serializing to/from POD\r\n  - asynchronous and synchronous message handling\r\n  - threaded and non-threaded message handling\r\n\r\n### HTTP:\r\n  - simple HTTP client wrapper (use platform-specific APIs, or CURL as fallback)\r\n  - simple HTTP server (only on platforms which support this)\r\n  - HTTP pluggable-file-system\r\n  - make it easy to handle JSON + XML formatted data\r\n\r\n### Math:\r\n  - use GLM (http://glm.g-truc.net/0.9.5/index.html) as math lib\r\n\r\n### Timing:\r\n  - use a thin wrapper around C++11's std::chrono if supported by the platform/compiler\r\n  - fall back to platform-specific code if necessary\r\n\r\n### Lowlevel Rendering:\r\n  - low-level API wrapper implemented on top of OpenGL (ES2)\r\n  - base feature set is OpenGL ES2 plus some common extensions\r\n  - completely asynchronous resource loading\r\n  - Twiggy-style medium-level rendering API (http://flohofwoe.blogspot.de/2012/08/twiggy.html)\r\n  - shaders are \"source code\" (integrated into compile process, and linked into the executable)\r\n  - GLFW as window system glue on supported platforms \r\n\r\n### Highlevel Rendering:\r\n  [todo]\r\n\r\n### Asset Files:\r\n  - pluggable asset loaders\r\n  - hopefully support glTF (https://github.com/KhronosGroup/glTF)\r\n  - alternatively super-compact custom file format\r\n  - drahtgitter python package for generating and converting assets: https://github.com/floooh/drahtgitter\r\n  - use GLI for texture loading (http://www.g-truc.net/project-0024.html#menu)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}