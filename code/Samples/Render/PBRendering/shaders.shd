//------------------------------------------------------------------------------
//  shaders.shd
//  Annotated GLSL shaders for PBR sample.
// http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf
//------------------------------------------------------------------------------

@vs vs
@uniform mat4 modelViewProj ModelViewProj
@uniform mat4 modelView ModelView
@in vec4 position
@in vec3 normal
@out vec3 viewSpacePos
@out vec3 viewSpaceNormal
void main() {
    $position = modelViewProj * position;
    viewSpacePos = vec3(modelView * position);
    viewSpaceNormal = vec3(modelView * vec4(normal, 0.0));
}
@end

//------------------------------------------------------------------------------
//  perform gamma correction
@block Util
vec4 gamma(vec4 c) {
    return vec4(pow(c.xyz, vec3(1.0/2.2)), c.w);
}
@end

//------------------------------------------------------------------------------
//  BRDF functions
//
@block BRDF
vec3 Fschlick(vec3 F0, vec3 l, vec3 h) {
    return F0 + (vec3(1.0) - F0) * pow(1.0 - dot(l, h), 5.0);
}

float normalizedBlinnPhong(float specPower, float n_dot_h) {
    float normTerm = (specPower + 2.0) / 2.0 * 3.1415926;
    float blinnPhong = pow(n_dot_h, specPower);
    return normTerm * blinnPhong;
}
@end

@fs fs
@use Util BRDF
@uniform vec3 lightVec LightVec // must be in view space already
@in vec3 viewSpacePos
@in vec3 viewSpaceNormal
void main() {
    const float specPower = 256.0;
    const vec3 spec = vec3(0.01,0.01,0.01);
    const vec3 eyePos = vec3(0.0, 0.0, 0.0);    // in view space, eye pos is at origin
    vec3 n = normalize(viewSpaceNormal);        // surface normal
    vec3 v = normalize(eyePos - viewSpacePos);  // view vector
    vec3 l = lightVec.xyz;                      // light vector
    vec3 h = normalize(l + v);
    float n_dot_l = clamp(dot(n, l), 0.0, 1.0);
    float n_dot_h = clamp(dot(n, h), 0.0, 1.0);
    
    vec3 diffuse = vec3(n_dot_l);
    
    float specularTerm = normalizedBlinnPhong(specPower, n_dot_h);
    vec3 fresnelTerm = Fschlick(spec, l, h);
    
    vec3 c = diffuse + vec3(specularTerm * n_dot_l);
    $color = gamma(vec4(c, 1.0));
}
@end

@bundle Main
@program vs fs
@end


