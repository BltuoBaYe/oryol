//------------------------------------------------------------------------------
//  the transform-feedback shader to compute the initial point positions
//
@uniform_block initParams Params
float num Num
@end

@vs initVS
@use_uniform_block initParams
@in vec3 position
@in vec3 normal
@out vec3 pos => position
@out vec3 vel => normal
    #if !ORYOL_GLSL || (ORYOL_GLSL_VERSION > 120)
    int n = int(num);
    float x = float( _vertexid % n);
    float y = float(( _vertexid / n) % n);
    pos.x = (x / float(n)) * 2.0 - 1.0;
    pos.y = (y / float(n)) * 2.0 - 1.0;
    pos.z = 0.0;
    #else
    pos = vec3(0.0);
    #endif
    vel = vec3(0.0);
    _position = vec4(0.0);
@end

@fs initFS
@in vec3 pos
@in vec3 vel
    discard;
    // WORKAROUND: use pos+vel so they won't be dropped by ANGLE
    _color = vec4(pos+vel, 1.0);
@end

@program InitShader initVS initFS

//------------------------------------------------------------------------------
// the transform-feedback shader to update the point cloud
//
@uniform_block captureParams Params
vec3 centerOfGravity CenterOfGravity
@end

@vs captureVS
@use_uniform_block captureParams
@in vec3 position
@in vec3 normal
@out vec3 pos => position
@out vec3 vel => normal
    vec3 dir = centerOfGravity - position;
    float dist = (length(dir) + 0.0001);
    float i = min(1.0 / (dist * dist), 20.0);
    vel = 0.995 * (normal + normalize(dir) * i);
    pos = position + vel * 0.0001;
    _position = vec4(0.0);
@end

@fs captureFS
@in vec3 pos
@in vec3 vel
    discard;
    // WORKAROUND: use pos+vel so they won't be dropped by ANGLE
    _color = vec4(pos+vel, 1.0);
@end

@program CaptureShader captureVS captureFS

//------------------------------------------------------------------------------
//  the rendering shader, which just renders a colored point lists
//
@uniform_block drawParams Params
mat4 mvp ModelViewProjection
@end

@vs drawVS
@use_uniform_block drawParams
@in vec4 position
@in vec3 normal
@out vec3 color
    _position = mul(mvp, position);
    _pointsize = 1.0;
    color = abs(normal) / 40.0;
@end

@fs drawFS
@in vec3 color
    _color = vec4(abs(color), 1.0);
@end

@program DrawShader drawVS drawFS


