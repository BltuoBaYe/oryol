//-----------------------------------------------------------------------------
// #version:5# machine generated, do not edit!
//-----------------------------------------------------------------------------
#include "Pre.h"
#include "shaders.h"

namespace Oryol {
namespace Shaders{
const char* canvasVS_100_src = 
"#define _POSITION gl_Position\n"
"attribute vec2 position;\n"
"attribute vec2 texcoord0;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_POSITION = vec4(((position.xy * 2.0) - 1.0), 0.0, 1.0);\n"
"_POSITION.y = -_POSITION.y;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* crtVS_100_src = 
"#define _POSITION gl_Position\n"
"attribute vec4 position;\n"
"attribute vec2 texcoord0;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_POSITION = position;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* canvasFS_100_src = 
"precision mediump float;\n"
"#define _COLOR gl_FragColor\n"
"#define _TEXTURE2D texture2D\n"
"uniform sampler2D tex;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_COLOR = _TEXTURE2D(tex, uv);\n"
"}\n"
;
const char* crtFS_100_src = 
"precision mediump float;\n"
"#define _COLOR gl_FragColor\n"
"#define _TEXTURE2D texture2D\n"
"uniform vec2 iResolution;\n"
"uniform sampler2D canvas;\n"
"varying vec2 uv;\n"
"#if 0\n"
"vec2 res=vec2(320.0/1.0,160.0/1.0);\n"
"#else\n"
"vec2 res = iResolution.xy / 2.0;\n"
"#endif\n"
"float hardScan=-8.0;\n"
"float hardPix=-2.0;\n"
"vec2 warp=vec2(1.0/24.0,1.0/16.0);\n"
"float maskDark=0.75;\n"
"float maskLight=2.0;\n"
"vec3 Fetch(sampler2D tex, vec2 pos, vec2 off){\n"
"pos = floor(pos * res + off) / res;\n"
"if (max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5) return vec3(0.0,0.0,0.0);\n"
"return _TEXTURE2D(tex, pos.xy).rgb;\n"
"}\n"
"vec2 Dist(vec2 pos) {\n"
"pos = pos * res;\n"
"return -((pos-floor(pos))-vec2(0.5));\n"
"}\n"
"float Gaus(float pos, float scale) {\n"
"return exp2(scale*pos*pos);\n"
"}\n"
"vec3 Horz3(sampler2D tex, vec2 pos,float off){\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wb=Gaus(dst-1.0,scale);\n"
"float wc=Gaus(dst+0.0,scale);\n"
"float wd=Gaus(dst+1.0,scale);\n"
"return (b*wb+c*wc+d*wd)/(wb+wc+wd);\n"
"}\n"
"vec3 Horz5(sampler2D tex, vec2 pos,float off) {\n"
"vec3 a=Fetch(tex, pos, vec2(-2.0,off));\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"vec3 e=Fetch(tex, pos, vec2( 2.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wa=Gaus(dst-2.0, scale);\n"
"float wb=Gaus(dst-1.0, scale);\n"
"float wc=Gaus(dst+0.0, scale);\n"
"float wd=Gaus(dst+1.0, scale);\n"
"float we=Gaus(dst+2.0, scale);\n"
"return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);\n"
"}\n"
"float Scan(vec2 pos,float off) {\n"
"float dst = Dist(pos).y;\n"
"return Gaus(dst+off, hardScan);\n"
"}\n"
"vec3 Tri(sampler2D tex, vec2 pos) {\n"
"vec3 a=Horz3(tex, pos, -1.0);\n"
"vec3 b=Horz5(tex, pos, 0.0);\n"
"vec3 c=Horz3(tex, pos, 1.0);\n"
"float wa=Scan(pos,-1.0);\n"
"float wb=Scan(pos, 0.0);\n"
"float wc=Scan(pos, 1.0);\n"
"return a*wa+b*wb+c*wc;\n"
"}\n"
"vec2 Warp(vec2 pos) {\n"
"pos=pos*2.0-1.0;\n"
"pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);\n"
"return pos*0.5+0.5;\n"
"}\n"
"vec3 Mask(vec2 pos) {\n"
"pos.x+=pos.y*3.0;\n"
"vec3 mask=vec3(maskDark,maskDark,maskDark);\n"
"pos.x=fract(pos.x/6.0);\n"
"if (pos.x < 0.333)    mask.r=maskLight;\n"
"else if (pos.x<0.666) mask.g=maskLight;\n"
"else                  mask.b=maskLight;\n"
"return mask;\n"
"}\n"
"vec4 tl_crt(sampler2D tex) {\n"
"vec2 pos=Warp(gl_FragCoord.xy / iResolution.xy);\n"
"return vec4(Tri(tex, pos) * Mask(gl_FragCoord.xy), 1.0);\n"
"}\n"
"void main() {\n"
"_COLOR = tl_crt(canvas);\n"
"}\n"
;
const char* canvasVS_120_src = 
"#version 120\n"
"#define _POSITION gl_Position\n"
"attribute vec2 position;\n"
"attribute vec2 texcoord0;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_POSITION = vec4(((position.xy * 2.0) - 1.0), 0.0, 1.0);\n"
"_POSITION.y = -_POSITION.y;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* crtVS_120_src = 
"#version 120\n"
"#define _POSITION gl_Position\n"
"attribute vec4 position;\n"
"attribute vec2 texcoord0;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_POSITION = position;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* canvasFS_120_src = 
"#version 120\n"
"#define _COLOR gl_FragColor\n"
"#define _TEXTURE2D texture2D\n"
"uniform sampler2D tex;\n"
"varying vec2 uv;\n"
"void main() {\n"
"_COLOR = _TEXTURE2D(tex, uv);\n"
"}\n"
;
const char* crtFS_120_src = 
"#version 120\n"
"#define _COLOR gl_FragColor\n"
"#define _TEXTURE2D texture2D\n"
"uniform vec2 iResolution;\n"
"uniform sampler2D canvas;\n"
"varying vec2 uv;\n"
"#if 0\n"
"vec2 res=vec2(320.0/1.0,160.0/1.0);\n"
"#else\n"
"vec2 res = iResolution.xy / 2.0;\n"
"#endif\n"
"float hardScan=-8.0;\n"
"float hardPix=-2.0;\n"
"vec2 warp=vec2(1.0/24.0,1.0/16.0);\n"
"float maskDark=0.75;\n"
"float maskLight=2.0;\n"
"vec3 Fetch(sampler2D tex, vec2 pos, vec2 off){\n"
"pos = floor(pos * res + off) / res;\n"
"if (max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5) return vec3(0.0,0.0,0.0);\n"
"return _TEXTURE2D(tex, pos.xy).rgb;\n"
"}\n"
"vec2 Dist(vec2 pos) {\n"
"pos = pos * res;\n"
"return -((pos-floor(pos))-vec2(0.5));\n"
"}\n"
"float Gaus(float pos, float scale) {\n"
"return exp2(scale*pos*pos);\n"
"}\n"
"vec3 Horz3(sampler2D tex, vec2 pos,float off){\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wb=Gaus(dst-1.0,scale);\n"
"float wc=Gaus(dst+0.0,scale);\n"
"float wd=Gaus(dst+1.0,scale);\n"
"return (b*wb+c*wc+d*wd)/(wb+wc+wd);\n"
"}\n"
"vec3 Horz5(sampler2D tex, vec2 pos,float off) {\n"
"vec3 a=Fetch(tex, pos, vec2(-2.0,off));\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"vec3 e=Fetch(tex, pos, vec2( 2.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wa=Gaus(dst-2.0, scale);\n"
"float wb=Gaus(dst-1.0, scale);\n"
"float wc=Gaus(dst+0.0, scale);\n"
"float wd=Gaus(dst+1.0, scale);\n"
"float we=Gaus(dst+2.0, scale);\n"
"return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);\n"
"}\n"
"float Scan(vec2 pos,float off) {\n"
"float dst = Dist(pos).y;\n"
"return Gaus(dst+off, hardScan);\n"
"}\n"
"vec3 Tri(sampler2D tex, vec2 pos) {\n"
"vec3 a=Horz3(tex, pos, -1.0);\n"
"vec3 b=Horz5(tex, pos, 0.0);\n"
"vec3 c=Horz3(tex, pos, 1.0);\n"
"float wa=Scan(pos,-1.0);\n"
"float wb=Scan(pos, 0.0);\n"
"float wc=Scan(pos, 1.0);\n"
"return a*wa+b*wb+c*wc;\n"
"}\n"
"vec2 Warp(vec2 pos) {\n"
"pos=pos*2.0-1.0;\n"
"pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);\n"
"return pos*0.5+0.5;\n"
"}\n"
"vec3 Mask(vec2 pos) {\n"
"pos.x+=pos.y*3.0;\n"
"vec3 mask=vec3(maskDark,maskDark,maskDark);\n"
"pos.x=fract(pos.x/6.0);\n"
"if (pos.x < 0.333)    mask.r=maskLight;\n"
"else if (pos.x<0.666) mask.g=maskLight;\n"
"else                  mask.b=maskLight;\n"
"return mask;\n"
"}\n"
"vec4 tl_crt(sampler2D tex) {\n"
"vec2 pos=Warp(gl_FragCoord.xy / iResolution.xy);\n"
"return vec4(Tri(tex, pos) * Mask(gl_FragCoord.xy), 1.0);\n"
"}\n"
"void main() {\n"
"_COLOR = tl_crt(canvas);\n"
"}\n"
;
const char* canvasVS_150_src = 
"#version 150\n"
"#define _POSITION gl_Position\n"
"in vec2 position;\n"
"in vec2 texcoord0;\n"
"out vec2 uv;\n"
"void main() {\n"
"_POSITION = vec4(((position.xy * 2.0) - 1.0), 0.0, 1.0);\n"
"_POSITION.y = -_POSITION.y;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* crtVS_150_src = 
"#version 150\n"
"#define _POSITION gl_Position\n"
"in vec4 position;\n"
"in vec2 texcoord0;\n"
"out vec2 uv;\n"
"void main() {\n"
"_POSITION = position;\n"
"uv = texcoord0;\n"
"}\n"
;
const char* canvasFS_150_src = 
"#version 150\n"
"#define _COLOR _FragColor\n"
"#define _TEXTURE2D texture\n"
"uniform sampler2D tex;\n"
"in vec2 uv;\n"
"out vec4 _FragColor;\n"
"void main() {\n"
"_COLOR = _TEXTURE2D(tex, uv);\n"
"}\n"
;
const char* crtFS_150_src = 
"#version 150\n"
"#define _COLOR _FragColor\n"
"#define _TEXTURE2D texture\n"
"uniform vec2 iResolution;\n"
"uniform sampler2D canvas;\n"
"in vec2 uv;\n"
"out vec4 _FragColor;\n"
"#if 0\n"
"vec2 res=vec2(320.0/1.0,160.0/1.0);\n"
"#else\n"
"vec2 res = iResolution.xy / 2.0;\n"
"#endif\n"
"float hardScan=-8.0;\n"
"float hardPix=-2.0;\n"
"vec2 warp=vec2(1.0/24.0,1.0/16.0);\n"
"float maskDark=0.75;\n"
"float maskLight=2.0;\n"
"vec3 Fetch(sampler2D tex, vec2 pos, vec2 off){\n"
"pos = floor(pos * res + off) / res;\n"
"if (max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5) return vec3(0.0,0.0,0.0);\n"
"return _TEXTURE2D(tex, pos.xy).rgb;\n"
"}\n"
"vec2 Dist(vec2 pos) {\n"
"pos = pos * res;\n"
"return -((pos-floor(pos))-vec2(0.5));\n"
"}\n"
"float Gaus(float pos, float scale) {\n"
"return exp2(scale*pos*pos);\n"
"}\n"
"vec3 Horz3(sampler2D tex, vec2 pos,float off){\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wb=Gaus(dst-1.0,scale);\n"
"float wc=Gaus(dst+0.0,scale);\n"
"float wd=Gaus(dst+1.0,scale);\n"
"return (b*wb+c*wc+d*wd)/(wb+wc+wd);\n"
"}\n"
"vec3 Horz5(sampler2D tex, vec2 pos,float off) {\n"
"vec3 a=Fetch(tex, pos, vec2(-2.0,off));\n"
"vec3 b=Fetch(tex, pos, vec2(-1.0,off));\n"
"vec3 c=Fetch(tex, pos, vec2( 0.0,off));\n"
"vec3 d=Fetch(tex, pos, vec2( 1.0,off));\n"
"vec3 e=Fetch(tex, pos, vec2( 2.0,off));\n"
"float dst=Dist(pos).x;\n"
"float scale=hardPix;\n"
"float wa=Gaus(dst-2.0, scale);\n"
"float wb=Gaus(dst-1.0, scale);\n"
"float wc=Gaus(dst+0.0, scale);\n"
"float wd=Gaus(dst+1.0, scale);\n"
"float we=Gaus(dst+2.0, scale);\n"
"return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);\n"
"}\n"
"float Scan(vec2 pos,float off) {\n"
"float dst = Dist(pos).y;\n"
"return Gaus(dst+off, hardScan);\n"
"}\n"
"vec3 Tri(sampler2D tex, vec2 pos) {\n"
"vec3 a=Horz3(tex, pos, -1.0);\n"
"vec3 b=Horz5(tex, pos, 0.0);\n"
"vec3 c=Horz3(tex, pos, 1.0);\n"
"float wa=Scan(pos,-1.0);\n"
"float wb=Scan(pos, 0.0);\n"
"float wc=Scan(pos, 1.0);\n"
"return a*wa+b*wb+c*wc;\n"
"}\n"
"vec2 Warp(vec2 pos) {\n"
"pos=pos*2.0-1.0;\n"
"pos*=vec2(1.0+(pos.y*pos.y)*warp.x,1.0+(pos.x*pos.x)*warp.y);\n"
"return pos*0.5+0.5;\n"
"}\n"
"vec3 Mask(vec2 pos) {\n"
"pos.x+=pos.y*3.0;\n"
"vec3 mask=vec3(maskDark,maskDark,maskDark);\n"
"pos.x=fract(pos.x/6.0);\n"
"if (pos.x < 0.333)    mask.r=maskLight;\n"
"else if (pos.x<0.666) mask.g=maskLight;\n"
"else                  mask.b=maskLight;\n"
"return mask;\n"
"}\n"
"vec4 tl_crt(sampler2D tex) {\n"
"vec2 pos=Warp(gl_FragCoord.xy / iResolution.xy);\n"
"return vec4(Tri(tex, pos) * Mask(gl_FragCoord.xy), 1.0);\n"
"}\n"
"void main() {\n"
"_COLOR = tl_crt(canvas);\n"
"}\n"
;
ProgramBundleSetup Canvas::CreateSetup() {
    ProgramBundleSetup setup("Canvas");
    setup.AddProgramFromSources(0, ShaderLang::GLSL100, canvasVS_100_src, canvasFS_100_src);
    setup.AddProgramFromSources(0, ShaderLang::GLSL120, canvasVS_120_src, canvasFS_120_src);
    setup.AddProgramFromSources(0, ShaderLang::GLSL150, canvasVS_150_src, canvasFS_150_src);
    setup.AddTextureUniform("tex", Texture);
    return setup;
}
ProgramBundleSetup CRT::CreateSetup() {
    ProgramBundleSetup setup("CRT");
    setup.AddProgramFromSources(0, ShaderLang::GLSL100, crtVS_100_src, crtFS_100_src);
    setup.AddProgramFromSources(0, ShaderLang::GLSL120, crtVS_120_src, crtFS_120_src);
    setup.AddProgramFromSources(0, ShaderLang::GLSL150, crtVS_150_src, crtFS_150_src);
    setup.AddUniform("iResolution", Resolution);
    setup.AddTextureUniform("canvas", Canvas);
    return setup;
}
}
}

